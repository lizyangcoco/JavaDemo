

******Mysql中的锁*****

概念一:表级锁->  锁整个表,加锁快,不出现死锁,发生锁冲突较高    并发度低
概念二:行级锁->  锁具体行,加锁慢,会出现死锁,发生锁冲突较低    并发度高
概念三:页面锁->  开销和加锁时间界于表锁和行锁之间,全部介于表行锁之间


一:表锁
两种模式:
1:表共享读锁
    :lock table 表名 read
    注意:锁表后不可加别名查询
2:表共享写锁
    :lock table 表名 write
    注意:
二:行锁
1:行锁的共享锁
2:排它锁

三:间隙锁
概念:锁一段范围
加锁方式:
    1:单数据锁到最后一位+1
    2:非主键索引锁下层范围,主键锁对应的单独位置 


*****MyISAM的表锁
总结:
    1:读操作,不会阻塞其他用户对<同一表>的读请求 ;
    2:读操作,不会阻塞当前session对表读,当进行修改时会报错 ;
    3:一个session给某表读锁,这个session可以查询锁定表的记录,单是更新或访问其他都会报错 


   4:写操作,会阻塞其他用户对同一表的读写操作 ;
   5:写操作,当前session对本表进行CRUD,其他表报错 

   ****读写互斥,读读相同,写写不存****

*****Innodb的行锁
两种模式:BEGIN<开启事务>  ROLLBACK<事务回滚> COMMIT<事务提交>
1:共享锁(读锁)
    :上读锁,允许其他进行读,不允许写,允许上读锁不允许上排它锁 
2:排它锁(写锁)
    :不允许其他写,但允许读,不允许上锁,包括写锁 


事务的特性:事务的四个属性
1:原子性  A-B事务为一个整体 ;
2:一致性  A-B事务产生的结果相平衡 ;
3:持久性  一旦提交对应数据为一致永久
4:隔离性
    数据的隔离级别(由低到高)
        (1):未提交读<uncommitted>
        (2):可提交读<committed>   解决脏读,产生不可重复读,commint之前和commint之后数据不同
        (3):可重复读<repeatable-默认隔离级别> 事务内读取不变,必须commint()后,才可读取
        (4):可串行化<事务未提交,插入删除一直等待>
数据读取概念
1:脏读
    <事务未提交/回滚/读取产生不一致>
    事务A读取了事务B的更新数据,然后事务B回滚,事务A读取到的数据就为脏读
2:不可重复读
    <读取不一致>
    事务A多次读取一个数据,事务B在事务A多次读取的过程中修改了值,导致A读取的数据不一致 (数目不变)
3:幻读(锁表完成的)
    <数据量不同>
    原有3条,由于别的事务进行删除等,读取到2条,数目不一致 

*****事务的特性*****
事务隔离级别                  脏读          不可重复读           幻读
未提交读<uncommitted>         是             是               是
可提交读<committed>           否             是               是
可重复读<repeatable-read>     否             否               是<mysql解决>
串行化<serializable>          否             否               否<锁表完成的>















